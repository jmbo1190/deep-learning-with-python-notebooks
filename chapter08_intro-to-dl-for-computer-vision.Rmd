---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.8.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

<!-- #region colab_type="text" -->
This is a companion notebook for the book [Deep Learning with Python, Second Edition](https://www.manning.com/books/deep-learning-with-python-second-edition?a_aid=keras&a_bid=76564dff). For readability, it only contains runnable code blocks and section titles, and omits everything else in the book: text paragraphs, figures, and pseudocode.

**If you want to be able to follow what's going on, I recommend reading the notebook side by side with your copy of the book.**

This notebook was generated for TensorFlow 2.6.
<!-- #endregion -->

<!-- #region colab_type="text" -->
# Introduction to deep learning for computer vision
<!-- #endregion -->

<!-- #region colab_type="text" -->
## Introduction to convnets
<!-- #endregion -->

<!-- #region colab_type="text" -->
**Instantiating a small convnet**
<!-- #endregion -->

```{python colab_type="code"}
from tensorflow import keras
from tensorflow.keras import layers
inputs = keras.Input(shape=(28, 28, 1))
x = layers.Conv2D(filters=32, kernel_size=3, activation="relu")(inputs)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=64, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=128, kernel_size=3, activation="relu")(x)
x = layers.Flatten()(x)
outputs = layers.Dense(10, activation="softmax")(x)
model = keras.Model(inputs=inputs, outputs=outputs)
```

<!-- #region colab_type="text" -->
**Displaying the model's summary**
<!-- #endregion -->

```{python colab_type="code"}
model.summary()
```

<!-- #region colab_type="text" -->
**Training the convnet on MNIST images**
<!-- #endregion -->

```{python colab_type="code"}
from tensorflow.keras.datasets import mnist

(train_images, train_labels), (test_images, test_labels) = mnist.load_data()
train_images = train_images.reshape((60000, 28, 28, 1))
train_images = train_images.astype("float32") / 255
test_images = test_images.reshape((10000, 28, 28, 1))
test_images = test_images.astype("float32") / 255
model.compile(optimizer="rmsprop",
    loss="sparse_categorical_crossentropy",
    metrics=["accuracy"])
model.fit(train_images, train_labels, epochs=5, batch_size=64)
```

<!-- #region colab_type="text" -->
**Evaluating the convnet**
<!-- #endregion -->

```{python colab_type="code"}
test_loss, test_acc = model.evaluate(test_images, test_labels)
print(f"Test accuracy: {test_acc:.3f}")
```

<!-- #region colab_type="text" -->
### The convolution operation
<!-- #endregion -->

<!-- #region colab_type="text" -->
#### Understanding border effects and padding
<!-- #endregion -->

<!-- #region colab_type="text" -->
#### Understanding convolution strides
<!-- #endregion -->

<!-- #region colab_type="text" -->
### The max-pooling operation
<!-- #endregion -->

<!-- #region colab_type="text" -->
**An incorrectly structured convnet missing its max-pooling layers**
<!-- #endregion -->

```{python colab_type="code"}
inputs = keras.Input(shape=(28, 28, 1))
x = layers.Conv2D(filters=32, kernel_size=3, activation="relu")(inputs)
x = layers.Conv2D(filters=64, kernel_size=3, activation="relu")(x)
x = layers.Conv2D(filters=128, kernel_size=3, activation="relu")(x)
x = layers.Flatten()(x)
outputs = layers.Dense(10, activation="softmax")(x)
model_no_max_pool = keras.Model(inputs=inputs, outputs=outputs)
```

```{python colab_type="code"}
model_no_max_pool.summary()
```

<!-- #region colab_type="text" -->
## Training a convnet from scratch on a small dataset
<!-- #endregion -->

<!-- #region colab_type="text" -->
### The relevance of deep learning for small-data problems
<!-- #endregion -->

<!-- #region colab_type="text" -->
### Downloading the data
<!-- #endregion -->

```{python colab_type="code"}
from google.colab import files
files.upload()
```

```{python colab_type="code"}
# !mkdir ~/.kaggle
# !cp kaggle.json ~/.kaggle/
# !chmod 600 ~/.kaggle/kaggle.json
```

```{python colab_type="code"}
# !kaggle competitions download -c dogs-vs-cats
```

```{python colab_type="code"}
# !unzip -qq train.zip
```

<!-- #region colab_type="text" -->
**Copying images to training, validation, and test directories**
<!-- #endregion -->

```{python colab_type="code"}
import os, shutil, pathlib

original_dir = pathlib.Path("train")
new_base_dir = pathlib.Path("cats_vs_dogs_small")

def make_subset(subset_name, start_index, end_index):
    for category in ("cat", "dog"):
        dir = new_base_dir / subset_name / category
        os.makedirs(dir)
        fnames = [f"{category}.{i}.jpg" for i in range(start_index, end_index)]
        for fname in fnames:
            shutil.copyfile(src=original_dir / fname,
                            dst=dir / fname)

make_subset("train", start_index=0, end_index=1000)
make_subset("validation", start_index=1000, end_index=1500)
make_subset("test", start_index=1500, end_index=2500)
```

<!-- #region colab_type="text" -->
### Building the model
<!-- #endregion -->

<!-- #region colab_type="text" -->
**Instantiating a small convnet for dogs vs. cats classification**
<!-- #endregion -->

```{python colab_type="code"}
from tensorflow import keras
from tensorflow.keras import layers

inputs = keras.Input(shape=(180, 180, 3))
x = layers.Rescaling(1./255)(inputs)
x = layers.Conv2D(filters=32, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=64, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=128, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=256, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=256, kernel_size=3, activation="relu")(x)
x = layers.Flatten()(x)
outputs = layers.Dense(1, activation="sigmoid")(x)
model = keras.Model(inputs=inputs, outputs=outputs)
```

```{python colab_type="code"}
model.summary()
```

<!-- #region colab_type="text" -->
**Configuring the model for training**
<!-- #endregion -->

```{python colab_type="code"}
model.compile(loss="binary_crossentropy",
              optimizer="rmsprop",
              metrics=["accuracy"])
```

<!-- #region colab_type="text" -->
### Data preprocessing
<!-- #endregion -->

<!-- #region colab_type="text" -->
**Using `image_dataset_from_directory` to read images**
<!-- #endregion -->

```{python colab_type="code"}
from tensorflow.keras.utils import image_dataset_from_directory

train_dataset = image_dataset_from_directory(
    new_base_dir / "train",
    image_size=(180, 180),
    batch_size=32)
validation_dataset = image_dataset_from_directory(
    new_base_dir / "validation",
    image_size=(180, 180),
    batch_size=32)
test_dataset = image_dataset_from_directory(
    new_base_dir / "test",
    image_size=(180, 180),
    batch_size=32)
```

```{python colab_type="code"}
import numpy as np
import tensorflow as tf
random_numbers = np.random.normal(size=(1000, 16))
dataset = tf.data.Dataset.from_tensor_slices(random_numbers)
```

```{python colab_type="code"}
for i, element in enumerate(dataset):
    print(element.shape)
    if i >= 2:
        break
```

```{python colab_type="code"}
batched_dataset = dataset.batch(32)
for i, element in enumerate(batched_dataset):
    print(element.shape)
    if i >= 2:
        break
```

```{python colab_type="code"}
reshaped_dataset = dataset.map(lambda x: tf.reshape(x, (4, 4)))
for i, element in enumerate(reshaped_dataset):
    print(element.shape)
    if i >= 2:
        break
```

<!-- #region colab_type="text" -->
**Displaying the shapes of the data and labels yielded by the `Dataset`**
<!-- #endregion -->

```{python colab_type="code"}
for data_batch, labels_batch in train_dataset:
    print("data batch shape:", data_batch.shape)
    print("labels batch shape:", labels_batch.shape)
    break
```

<!-- #region colab_type="text" -->
**Fitting the model using a `Dataset`**
<!-- #endregion -->

```{python colab_type="code"}
callbacks = [
    keras.callbacks.ModelCheckpoint(
        filepath="convnet_from_scratch.keras",
        save_best_only=True,
        monitor="val_loss")
]
history = model.fit(
    train_dataset,
    epochs=30,
    validation_data=validation_dataset,
    callbacks=callbacks)
```

<!-- #region colab_type="text" -->
**Displaying curves of loss and accuracy during training**
<!-- #endregion -->

```{python colab_type="code"}
import matplotlib.pyplot as plt
accuracy = history.history["accuracy"]
val_accuracy = history.history["val_accuracy"]
loss = history.history["loss"]
val_loss = history.history["val_loss"]
epochs = range(1, len(accuracy) + 1)
plt.plot(epochs, accuracy, "bo", label="Training accuracy")
plt.plot(epochs, val_accuracy, "b", label="Validation accuracy")
plt.title("Training and validation accuracy")
plt.legend()
plt.figure()
plt.plot(epochs, loss, "bo", label="Training loss")
plt.plot(epochs, val_loss, "b", label="Validation loss")
plt.title("Training and validation loss")
plt.legend()
plt.show()
```

<!-- #region colab_type="text" -->
**Evaluating the model on the test set**
<!-- #endregion -->

```{python colab_type="code"}
test_model = keras.models.load_model("convnet_from_scratch.keras")
test_loss, test_acc = test_model.evaluate(test_dataset)
print(f"Test accuracy: {test_acc:.3f}")
```

<!-- #region colab_type="text" -->
### Using data augmentation
<!-- #endregion -->

<!-- #region colab_type="text" -->
**Define a data augmentation stage to add to an image model**
<!-- #endregion -->

```{python colab_type="code"}
data_augmentation = keras.Sequential(
    [
        layers.RandomFlip("horizontal"),
        layers.RandomRotation(0.1),
        layers.RandomZoom(0.2),
    ]
)
```

<!-- #region colab_type="text" -->
**Displaying some randomly augmented training images**
<!-- #endregion -->

```{python colab_type="code"}
plt.figure(figsize=(10, 10))
for images, _ in train_dataset.take(1):
    for i in range(9):
        augmented_images = data_augmentation(images)
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(augmented_images[0].numpy().astype("uint8"))
        plt.axis("off")
```

<!-- #region colab_type="text" -->
**Defining a new convnet that includes image augmentation and dropout**
<!-- #endregion -->

```{python colab_type="code"}
inputs = keras.Input(shape=(180, 180, 3))
x = data_augmentation(inputs)
x = layers.Rescaling(1./255)(x)
x = layers.Conv2D(filters=32, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=64, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=128, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=256, kernel_size=3, activation="relu")(x)
x = layers.MaxPooling2D(pool_size=2)(x)
x = layers.Conv2D(filters=256, kernel_size=3, activation="relu")(x)
x = layers.Flatten()(x)
x = layers.Dropout(0.5)(x)
outputs = layers.Dense(1, activation="sigmoid")(x)
model = keras.Model(inputs=inputs, outputs=outputs)

model.compile(loss="binary_crossentropy",
              optimizer="rmsprop",
              metrics=["accuracy"])
```

<!-- #region colab_type="text" -->
**Training the regularized convnet**
<!-- #endregion -->

```{python colab_type="code"}
callbacks = [
    keras.callbacks.ModelCheckpoint(
        filepath="convnet_from_scratch_with_augmentation.keras",
        save_best_only=True,
        monitor="val_loss")
]
history = model.fit(
    train_dataset,
    epochs=100,
    validation_data=validation_dataset,
    callbacks=callbacks)
```

<!-- #region colab_type="text" -->
**Evaluating the model on the test set**
<!-- #endregion -->

```{python colab_type="code"}
test_model = keras.models.load_model(
    "convnet_from_scratch_with_augmentation.keras")
test_loss, test_acc = test_model.evaluate(test_dataset)
print(f"Test accuracy: {test_acc:.3f}")
```

<!-- #region colab_type="text" -->
## Leveraging a pretrained model
<!-- #endregion -->

<!-- #region colab_type="text" -->
### Feature extraction with a pretrained model
<!-- #endregion -->

<!-- #region colab_type="text" -->
**Instantiating the VGG16 convolutional base**
<!-- #endregion -->

```{python colab_type="code"}
conv_base = keras.applications.vgg16.VGG16(
    weights="imagenet",
    include_top=False,
    input_shape=(180, 180, 3))
```

```{python colab_type="code"}
conv_base.summary()
```

<!-- #region colab_type="text" -->
#### Fast feature extraction without data augmentation
<!-- #endregion -->

<!-- #region colab_type="text" -->
**Extracting the VGG16 features and corresponding labels**
<!-- #endregion -->

```{python colab_type="code"}
import numpy as np

def get_features_and_labels(dataset):
    all_features = []
    all_labels = []
    for images, labels in dataset:
        preprocessed_images = keras.applications.vgg16.preprocess_input(images)
        features = conv_base.predict(preprocessed_images)
        all_features.append(features)
        all_labels.append(labels)
    return np.concatenate(all_features), np.concatenate(all_labels)

train_features, train_labels =  get_features_and_labels(train_dataset)
val_features, val_labels =  get_features_and_labels(validation_dataset)
test_features, test_labels =  get_features_and_labels(test_dataset)
```

```{python colab_type="code"}
train_features.shape
```

<!-- #region colab_type="text" -->
**Defining and training the densely connected classifier**
<!-- #endregion -->

```{python colab_type="code"}
inputs = keras.Input(shape=(5, 5, 512))
x = layers.Flatten()(inputs)
x = layers.Dense(256)(x)
x = layers.Dropout(0.5)(x)
outputs = layers.Dense(1, activation="sigmoid")(x)
model = keras.Model(inputs, outputs)
model.compile(loss="binary_crossentropy",
              optimizer="rmsprop",
              metrics=["accuracy"])

callbacks = [
    keras.callbacks.ModelCheckpoint(
      filepath="feature_extraction.keras",
      save_best_only=True,
      monitor="val_loss")
]
history = model.fit(
    train_features, train_labels,
    epochs=20,
    validation_data=(val_features, val_labels),
    callbacks=callbacks)
```

<!-- #region colab_type="text" -->
**Plotting the results**
<!-- #endregion -->

```{python colab_type="code"}
import matplotlib.pyplot as plt
acc = history.history["accuracy"]
val_acc = history.history["val_accuracy"]
loss = history.history["loss"]
val_loss = history.history["val_loss"]
epochs = range(1, len(acc) + 1)
plt.plot(epochs, acc, "bo", label="Training accuracy")
plt.plot(epochs, val_acc, "b", label="Validation accuracy")
plt.title("Training and validation accuracy")
plt.legend()
plt.figure()
plt.plot(epochs, loss, "bo", label="Training loss")
plt.plot(epochs, val_loss, "b", label="Validation loss")
plt.title("Training and validation loss")
plt.legend()
plt.show()
```

<!-- #region colab_type="text" -->
#### Feature extraction together with data augmentation
<!-- #endregion -->

<!-- #region colab_type="text" -->
**Instantiating and freezing the VGG16 convolutional base**
<!-- #endregion -->

```{python colab_type="code"}
conv_base  = keras.applications.vgg16.VGG16(
    weights="imagenet",
    include_top=False)
conv_base.trainable = False
```

<!-- #region colab_type="text" -->
**Printing the list of trainable weights before and after freezing**
<!-- #endregion -->

```{python colab_type="code"}
conv_base.trainable = True
print("This is the number of trainable weights "
      "before freezing the conv base:", len(conv_base.trainable_weights))
```

```{python colab_type="code"}
conv_base.trainable = False
print("This is the number of trainable weights "
      "after freezing the conv base:", len(conv_base.trainable_weights))
```

<!-- #region colab_type="text" -->
**Adding a data augmentation stage and a classifier to the convolutional base**
<!-- #endregion -->

```{python colab_type="code"}
data_augmentation = keras.Sequential(
    [
        layers.RandomFlip("horizontal"),
        layers.RandomRotation(0.1),
        layers.RandomZoom(0.2),
    ]
)

inputs = keras.Input(shape=(180, 180, 3))
x = data_augmentation(inputs)
x = keras.applications.vgg16.preprocess_input(x)
x = conv_base(x)
x = layers.Flatten()(x)
x = layers.Dense(256)(x)
x = layers.Dropout(0.5)(x)
outputs = layers.Dense(1, activation="sigmoid")(x)
model = keras.Model(inputs, outputs)
model.compile(loss="binary_crossentropy",
              optimizer="rmsprop",
              metrics=["accuracy"])
```

```{python colab_type="code"}
callbacks = [
    keras.callbacks.ModelCheckpoint(
        filepath="feature_extraction_with_data_augmentation.keras",
        save_best_only=True,
        monitor="val_loss")
]
history = model.fit(
    train_dataset,
    epochs=50,
    validation_data=validation_dataset,
    callbacks=callbacks)
```

<!-- #region colab_type="text" -->
**Evaluating the model on the test set**
<!-- #endregion -->

```{python colab_type="code"}
test_model = keras.models.load_model(
    "feature_extraction_with_data_augmentation.keras")
test_loss, test_acc = test_model.evaluate(test_dataset)
print(f"Test accuracy: {test_acc:.3f}")
```

<!-- #region colab_type="text" -->
### Fine-tuning a pretrained model
<!-- #endregion -->

```{python colab_type="code"}
conv_base.summary()
```

<!-- #region colab_type="text" -->
**Freezing all layers until the fourth from the last**
<!-- #endregion -->

```{python colab_type="code"}
conv_base.trainable = True
for layer in conv_base.layers[:-4]:
    layer.trainable = False
```

<!-- #region colab_type="text" -->
**Fine-tuning the model**
<!-- #endregion -->

```{python colab_type="code"}
model.compile(loss="binary_crossentropy",
              optimizer=keras.optimizers.RMSprop(learning_rate=1e-5),
              metrics=["accuracy"])

callbacks = [
    keras.callbacks.ModelCheckpoint(
        filepath="fine_tuning.keras",
        save_best_only=True,
        monitor="val_loss")
]
history = model.fit(
    train_dataset,
    epochs=30,
    validation_data=validation_dataset,
    callbacks=callbacks)
```

```{python colab_type="code"}
model = keras.models.load_model("fine_tuning.keras")
test_loss, test_acc = model.evaluate(test_dataset)
print(f"Test accuracy: {test_acc:.3f}")
```

<!-- #region colab_type="text" -->
## Summary
<!-- #endregion -->
